# SNext.js

> Build static sites with React

## Next.js + react-snap = SNext.js

## What is this?

This is an experimental library based on [new React 18 server capabilities](https://github.com/reactwg/react-18/discussions/37) that combine the spirit of [Next.js](https://github.com/vercel/next.js) with the idea behinded [react-snap](https://github.com/stereobooster/react-snap) of creating a static site by crawling all links.

To do this instead of using [puppeter](https://github.com/puppeteer/puppeteer) and wait to all request to finsh we use the output of your server side rendered application to crawl all the links. Thanks to React 18 we can execute all side effects of React tree using Suspense.

This project is an experimental stage and is based on ogoing React 18 RC apis but by tests seems working like a charm.

## Getting started

Install:

```sh
yarn add --dev snext
```

Change your `package.json`:

```json
{
  "scripts": {
    "dev": "snext dev",
    "build": "snext build",
    "staticize": "snext staticize"
  },
  "snext": {
    "clientEntry": "./src/index.js",
    "serverComponent": "./src/StaticApp.js",
    "skeletonComponent": "./src/Skeleton.js"
  }
}
```

The `dev` command wil start a dev server on port 7000 with fast refresh and hot module reload so you can try
both your client and server code.

The `build` command generate a intermediate folder with a production build of your client and server code.

The `staticize` command use the production code of `build` command to render your app using node and crawl your links to generate a static site with all of your routes.

The `serverComponent` is the path of your component rendered on the server.
In the `snext` mental model here you should be able to collect the result of your side effects that happends during render.

The Server Component receive the `url` prop from the server.

The Server Component file can export two special functions:

- `getStaticProps`: Used to inject extra props into the component before render
- `getSkeletonProps`: Used to inject props into the Skeleton component.

The `snext` library try to be more unopinated possible but for clarity we use the [react-query](https://github.com/tannerlinsley/react-query) library to handle suspense data fetching and the [react-router](https://github.com/remix-run/react-router) library to handle routing and show a real world example.

```jsx
import { dehydrate, QueryClient, QueryClientProvider } from 'react-query'
import { StaticRouter } from 'react-router-dom/server.js'
import App from './App'

// This the app render on the server tipically the inner app performs
// side effect during render both on server and client
// here we can inject the cache provider with a value created from
// server.
// Also here we use the url of server request to render the correc tree.
export default function StaticApp({ queryClient, url }) {
  return (
    <QueryClientProvider client={queryClient}>
      <StaticRouter location={url}>
        <App />
      </StaticRouter>
    </QueryClientProvider>
  )
}

// Create the query client on the server
// Tipically you need a mutable cache to write, this is hook
// can be used to create them.
// you can also perform other side effects and return them as props
// (the original Next.js getStaticProps)
export const getStaticProps = async ({ url }) => {
  return {
    props: {
      queryClient: new QueryClient({
        defaultOptions: {
          queries: {
            cacheTime: Infinity,
            refetchOnWindowFocus: false,
            refetchOnReconnect: false,
            refetchInterval: false,
            refetchIntervalInBackground: false,
            refetchOnMount: false,
            staleTime: Infinity,
            suspense: true,
          },
        },
      }),
    },
  }
}

// Here as second argument you have the props injected before
// you can use this hook to dump the values write in the cache
// into a serializable format
export const getSkeletonProps = async ({ url }, { queryClient }) => {
  return {
    props: {
      initialData: dehydrate(queryClient),
    },
  }
}
```

The `skeletonEntry` is the component used to provide a shell to your server render app.
The skeleton component is rendered after the server component has finish all side effects and we have its output.

The server component props are:

- `appHtml`: The html string of Server Component rendered,
- `entrypoints`: Strings of scripts or styles paths generated by the compilation step.
  Plus all the props injected by `getSkeletonProps`.

A Skeleton component looks like this:

```jsx
export default function Skeleton({ appHtml, initialData, entrypoints }) {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="/favicon.ico" />
        {entrypoints
          .filter((e) => e.endsWith('.css'))
          .map((e) => (
            <link key={e} href={`/${e}`} rel="stylesheet" />
          ))}
      </head>
      <body>
        <div
          id="root"
          dangerouslySetInnerHTML={{
            __html: appHtml,
          }}
        />
      </body>
      <script
        dangerouslySetInnerHTML={{
          __html: `window.__INITIAL_DATA__ = ${JSON.stringify(initialData)};`,
        }}
      />
      {entrypoints
        .filter((e) => e.endsWith('.js'))
        .map((e) => (
          <script key={e} src={`/${e}`} />
        ))}
    </html>
  )
}
```

The `clientEntry` is the path for your browser entry point.
Here we use the initial data injected by the Skeleton to hydrate the state of our app.

To complete the example above here the client entry:

```jsx
import { hydrateRoot } from 'react-dom'
import { BrowserRouter } from 'react-router-dom'
import App from './App'

hydrate(queryClient, window.__INITIAL_DATA__)
delete window.__INITIAL_DATA__

hydrateRoot(
  document.getElementById('root'),
  <QueryClientProvider client={queryClient}>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </QueryClientProvider>
)
```

You can find the complete example [here](./examples/pokedex).

## Running node specific code

You can run specefic node code wherever you want using `process.env.IS_SNEXT_SERVER`.
This special expression in statically replaced with `true` in node environment and `false` on
client.
Note, all node native modules are empty modules in client javascript.

```js
// Empty module in client
import fs from 'fs'

// Removed in production client bundle by tree shaking
function readMy() {
  return fs.readFileSync('something.json', 'utf-8')
}

if (process.env.IS_SNEXT_SERVER) {
  // Never shipped to client bundle
  readMy()
}
```

## Configure

Here all the available snext options with their defaults:

```json
{
  "scripts": {
    "dev": "snext dev",
    "build": "snext build",
    "staticize": "snext staticize"
  },
  "snext": {
    "clientEntry": "./path/to/file",
    "serverComponent": "./path/to/file",
    "skeletonComponent": "./path/to/file",
    "port": 7000,
    "outputDir": "build",
    "publicDir": "public",
    "compileNodeCommonJS": false,
    "urls": ["/"],
    "crawlConcurrency": 4,
    "proxy": null,
  }
}
```

## Typescript

Typescript is available out of the box, add a `tsconfig.json` in the root of your project
and snext will use compile typescript.
Look [here](./examples/typescript-pokedex) to see a complete typescript example.

## Node ESM

The snext package itself is [pure ESM package](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c),
also your code is compiled as node ESM, however you can omit file extension in relative import cause your code will be bundled
as a single file, on the other hand you have to write explicit extension for node_modules import for example:

```js
import { StaticRouter } from 'react-router-dom/server.js'
```

You can also compile your code as commonJS, if you want, with:

```json
{
  "snext": {
    "compileNodeCommonJS": true
  }
}
```

With commonJS the hot reload of node code is a litte bit faster (the implementation is more tricky) and you
can omit file extension for node_modules dependency but you can't import pure ESM modules.

## No Javascript

If your website has no interaction except for links you can decide to ship
it without ANY Javascript.

With snext doing it's simple, hack you Skeleton Component:

```jsx
export default function Skeleton({ appHtml, initialData, entrypoints }) {
  return (
    <html>
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="shortcut icon" href="/favicon.ico" />
        {entrypoints
          .filter((e) => e.endsWith('.css'))
          .map((e) => (
            <link key={e} href={`/${e}`} rel="stylesheet" />
          ))}
      </head>
      <body>
        <div
          id="root"
          dangerouslySetInnerHTML={{
            __html: appHtml,
          }}
        />
      </body>
      {/* In DEV we use javascript for hot reload =) */}
      {process.env.NODE_ENV !== 'production' && (
        <>
          <script
            dangerouslySetInnerHTML={{
              __html: `window.__INITIAL_DATA__ = ${JSON.stringify(
                initialData
              )};`,
            }}
          />
          {entrypoints
            .filter((e) => e.endsWith('.js'))
            .map((e) => (
              <script key={e} src={`/${e}`} />
            ))}
        </>
      )}
    </html>
  )
}
```

To a more complete example check the [blog example](./examples/blog).

## Crawling

When running `staticize` all `<a>` with a relative `href` will be crawled,
we `crawl` also the `data-crawl-url` for case where you can't render a link
for example table rows.

The default starting point of crawling is `/` you can customize the urls to start:

```json
{
  "snext": {
    "urls": ["/", "/blog", "/about"]
  }
}
```

You can also tweak crawling concurrency with:

```json
{
  "snext": {
    "crawlConcurrency": 1
  }
}
```

## Proxy

To add an url to proxy:

```json
{
  "snext": {
    "proxy": "http://somehost"
  }
}
```

Note that when crawling we are not running an http server so proxy wont
works so you can have something like this in your code:

```js
export const API_URL = process.env.IS_SNEXT_SERVER ? 'https://somehost' : ''
```



## [EXAMPLES](./examples)

## TODO:

- [ ] More css loaders, css modules, sass (?), post css ecc ...
- [ ] Generic file loader
- [ ] Add Helmet example in blog example
- [ ] Custom env ecc

## LICENSE

MIT
